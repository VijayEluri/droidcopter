package org.haldean.chopper;

import android.graphics.PixelFormat;
import android.hardware.Camera;
import android.hardware.Camera.ErrorCallback;
import android.hardware.Camera.Parameters;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;

public final class MakePicture extends Thread implements Constants
{
	private static Camera camera;
	public static byte[] buffer = new byte[0];
	public static byte[] lastpic = new byte[0];
	
	//Variables used for calculating how long it takes to make a snapshot.

	private static long picstart;
	private static long picend;
	private static long pictime;
	
	private static Camera.PictureCallback SendPic;
	private static Camera.ErrorCallback error;
	
	private static Handler mHandler;
	
	public MakePicture()
	{
		super();
		
		//Initialize the camera, get a lock
		if (camera == null)
			camera = Camera.open();

		//set up callbacks.  First is on error, second is on picture taken.
		error = new ErrorCallback()
		{
			public void onError(int error, Camera camera)
			{
				System.out.println("Camera error, code " + error);
			}
		};
		
		//anonymous callback class, with instructions on what to do with the image data once available
		SendPic = new Camera.PictureCallback()
		{
			public void onPictureTaken(byte[] imageData, Camera c)
			{
				System.out.println("SendPic onPictureTaken() thread ID " + getId());
				if (imageData != null)
				{
					
					picend = System.currentTimeMillis();
					pictime = picend - picstart;
					System.out.println("Picture succesfully taken, in " + pictime + " milliseconds.");
					
					synchronized (buffer)
					{
						buffer = imageData; //set the class buffer to the image data, for other threads to use
					}
				}
				else
				{
					System.out.println("Callback intiated, but picture null.  Confused.");
				}
				mHandler.sendEmptyMessageDelayed(CAMERAIDLE, CAMERAINTERVAL);
				System.out.println("Callback returning");
			}
		};
		//Inner class defs done
		
		//set specific parameters.  Later, may configure these to be operated remotely.
		Parameters params = camera.getParameters();
		params.setFlashMode(Parameters.FLASH_MODE_OFF);
		params.setPictureSize(XPIC, YPIC);
		params.setPictureFormat(PixelFormat.JPEG);
		params.setJpegQuality(JPEGQUALITY);
		
		//camera.setPreviewCallback(null);
		
		//Loads the new parameters.  Necessary!
		camera.setParameters(params);
		
		camera.setErrorCallback(error);
	}
	
	public void run()
	{
		Looper.prepare();
		
		System.out.println("MakePicture run() thread ID " + getId());
		
		mHandler = new Handler() {
            public void handleMessage(Message msg)
            {
                switch (msg.what) {
                case CAMERAIDLE:
                	picstart = System.currentTimeMillis();
                	camera.takePicture(null, null, SendPic); //takes the pic, starting a loop.
                }
            }
        };
        
        
		//Spawns a thread to take the picture
        picstart = System.currentTimeMillis();
		camera.takePicture(null, null, SendPic); //takes the pic, starting a loop.
		Looper.loop();
		/*PictureTaker taker = new PictureTaker(this);
		taker.start();
		
	}
	
	//thread-class to take a picture.
	private class PictureTaker extends Thread
	{
		//needs a reference to a parent, to notify it when ready.
		private PictureTaker (MakePicture myparent)
		{
			super();
			parent = myparent;
		}
		
		//Take a picture
		public void run()
		{
			picstart = System.currentTimeMillis();
			synchronized (camera)
			{
					
			}
		}*/
	}
}
